---
layout: default
title: 面试技术准备
nav_order: 3
---
### 讲讲Redis
#### Redis的基础能力
Redis是分布式内存数据库，单节点能够满足上千万的QPS，是作为分布式缓存所常用的组件

#### Redis应用
1、数据是先写入redis，还是先写入数据库。我们最后采取的是先写入redis，redis写入成功后，再写入数据库，这个考量是为了能够提升读写速度，即使是数据不一致，这个状态后续也会更新
2、数据缓存时效设置多久？以及怎么随机打散？因为上层的查询业务一般是按照一个集群id来批量获取，
3、redis缓存配置多大：
3c12g， 支持20w设备数据的缓存，最大750并发数，10000连接
redis高性能设计方案理解：
分布式锁：普通的锁ctx，集群模式是不是就解决了？

### 讲讲分库分表
水平分库分表，垂直分库分表
### 讲一讲JVM优化
垃圾回收算法：G1, 标注回收
存储里也有垃圾回收，通过LSMtree保存元数据，实际value需要通过GC算法进行回收
### 讲一讲Nginx

### 讲一讲Kudu
kudu在内存里是row式存储，在磁盘上是列式存储。我们做了什么

### 讲一讲Netty
netty是一个基于JavaNIO的通信框架，RPC是通过netty通信的，MP模块通过使用rpc通信提升图片传输速率


### 讲一讲Kafka

### 讲一讲系统演进的思考
1、缓存加速，使用redis，减少重复缓存使用量，检索性能提升（准备做）
2、VCM和VCN是使用两套统一鉴权
3、RPC消息统一，取代NSS消息体系
4、使用Hbase替换Mongodb，加速单数据或范围数据查找性能，工作量太大，这个一直没有实施

### 讲一讲存储架构
bloomfilter，lsmtree
ceph实现

### 讲讲树
B树：每个节点都有数据
B+树：只在叶子节点有数据，并且数据之间链路间是有跳转关系的，范围检索优势比较大
红黑树：一般是用在内存级的排序的map，内存操作快，相对排序层数不高
LSM-Tree：现在的kv型存储数据库的主流选择，能够极大的提升数据插入性能

### 讲一讲Solr
solr的日期检索优化range检索优化：
通过将solr的年月作为倒排的term，日作为payload存储，提升检索性能
用了什么样的分词器：分词器这个没有去研究，用的 默认的标准分词器，实际上我们存储的数据不需要分词
solr中做了哪些优化?
omitNorms设置为true，归一化参数，反应了词频和文档频率：
默认solr里会对因子做归一化处理？什么是归一化？对文档的权重，term的权重，term在文档长度中的频率等进行归一化的打分，取消这些可以节省空间和计算
omitPositions=true不涉及高亮的显示，不需要索引term的位置信息
通过设置docValue=true，提升facet查询的性能
solr权威指南2.5.2章节

### 讲一讲ElasticSearch

### 讲一讲Mongo
mongo设计：按照 每条数据大小评估总容量，按照索引占比，评估索引内存，按照缓存数据量，评估缓存大小
然后按照，服务器支持的磁盘和内存来评估服务器数量
怎么设置分区数？通过numInitTrunks来配置分片数
mongodb的分片大小建议控制在50GB以内，过大不利于分片迁移恢复

mongo优化：
查询性能优化：
1、mongo的实体关系对应：静态库的人脸特征，是用嵌套还是引用
2、索引未建立导致的慢查询
3、循环中查询mongo，导致的tps暴高
4、升级扩容，mongo无法加到分片中，权限配置生效失败

----