---
layout: default
title: redis
nav_order: 5
has_children: true
permalink: /docs/redis
---

# 秒杀场景设计
秒杀场景重点要考虑的问题就是高并发问题，我们要在系统的各个环节考虑这个问题
1、前端页面静态化，尽可能减少后端，只有刷新请求库存和秒杀这2个请求可以请求后端，页面其他单元通过CDN减少后端压力
2、请求库存，使用内存缓存，请求库存从redis里面获取库存量，如果内存里面没有，那么需要去数据库取库存，再放入缓存。 
2.1、 这里存在缓存击穿的风险：去数据库获取库存需要加分布式锁
    其他请求自旋锁，再次从内存获取，如果获取不到再加锁。当然这里可以做个缓存预取的功能
2.2、缓存穿透：如果商品都不存在，大量的去查询数据库，数据库也撑不住，需要布隆过滤器，不存在商品，则直接返回
3、秒杀请求：秒杀之后，需要支付才能最终扣减库存，所以需要预扣库存，预扣库存，也应该在redis里扣减库存，
    高并发下，可能有库存超卖，可以考虑使用Redis的lua脚本原子性，来保证库存扣减不小于0
4、使用redis做分布式锁，还有锁竞争问题、续期、锁重入、多个redis实例枷锁等问题 ，待了解
5、秒杀后，形成一个有时限的订单，需要支付后，才能形成最终订单和库存扣减，这个时候形成一个异步的有时限的事件(秒杀订单)，发布到MQ
6、发往MQ的消息可不能丢，必须成功，秒杀订单里要记录消息是否已发送的状态，也可以再设计一个表，记录这个消息是否已发布    
    支付模块消费数据以后，支付完成，再回调订单的接口，更改消息状态已处理。
7、由于增加了消息状态表，有可能记录了表成功，但是消息发送失败，那么就需要重试，重试带来的结果可能有重复消息。重复消息怎么处理呢？下单模块增加一个消息处理表
    处理过的消息，重复处理，则直接跳过
8、如果用户迟迟没有付钱，15分钟之后要取消订单，回退库存。消费后，设置为待支付状态，这个时候要发一条延迟消息，15分钟之后，消费后再来检查是否已支付
9、秒杀请求，有可能有人抢票，那应该如何限流：一种是基于nginx的限流，一种是基于redis的限流
    对于同一个用户可以每分钟多少次请求的方式
    对于同一个ip可以每分钟多少次请求的方式：但是这种限制方式，可能会造成误杀，比如同一个网吧里的，因为同一个网吧的出口ip是同一个
    另外就是可以对整体的请求次数加限制，但这种限制对系统的稳定性非常必要，但是对于非法请求过多，会影响到正常用户的访问
    
    加验证码：相比于上面三种方式，加验证码会更精准一些
    


# 流量治理


# 服务治理
服务可拆卸
服务间弱依赖
服务自治

升级、部署、备份、恢复、扩容框架设计和实现

k8s，zabbix，